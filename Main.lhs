> module Main where

This file brings together the various pieces that make up the hmk command. The
core logic is in Control.Hmk. That module knows only rules, from which it can
produce a schedule of recipes to run. Despite the name, it is the most generic
part of the application.

Rules may be generated by instantiating meta-rules, as often appears in
mkfile's. Instantiation of meta-rules is done by the parser, with the help of
the Metarule module. In fact most of the work is done by the parser, as it is
also the parser's job to carry forward any variable substitutions.

> import Control.Hmk
> import Parse
> import Data.ByteString.Lazy.Char8 (ByteString)
> import qualified Data.ByteString.Lazy.Char8 as B
> import Control.Monad (liftM)

The exit code of the command is the exit code of the last recipe executed.

> import System.IO
> import System.Exit
> import System.Environment
>
>
> guard p s x = if p x then return x else fail s
>
> main :: IO ()
> main = do
>   targets <- getArgs
>   rules <- B.readFile "mkfile"
>            >>= return . preprocess
>            >>= parse "mkfile"
>            >>= return . postprocess
>   guard (not . null) "No rules in mkfile." rules

Per the mk man page, if no targets are specified on the command line, then
assume the target is that of the first rule.

>   schedule <- case targets of
>               [] -> mk rules [target (head rules)]
>               _  -> mk rules targets
>   sequence_ schedule
